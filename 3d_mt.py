# -*- coding: utf-8 -*-
"""3D MT

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BQIYWYZw0q1psClltkMo3G7Uj4KmgMR4
"""

import numpy as np
from collections import deque
import networkx as nx
import matplotlib.pyplot as plt
import graphviz, pydot
from IPython.display import Image, display
import copy
import cv2

from pydrive.auth import GoogleAuth
from pydrive.drive import GoogleDrive
from google.colab import auth
from oauth2client.client import GoogleCredentials

# Authenticate and create the PyDrive client.
auth.authenticate_user()
gauth = GoogleAuth()
gauth.credentials = GoogleCredentials.get_application_default()
drive = GoogleDrive(gauth)

# data = np.random.randint(100, size=(5, 5, 5));
link = 'https://drive.google.com/open?id=1FIZRoqAxVVUVn37Dx9YMrcMv57g2u5PD'
fluff, id = link.split('=')
print(id)
downloaded = drive.CreateFile({'id': id})
downloaded.GetContentFile('Filename.csv')
with open('Filename.csv', 'rb') as infile:
    buf = infile.read()
data = np.fromstring(buf, dtype='uint8')
x_max = 301
y_max = 324
z_max = 56
data = np.array(data).reshape(x_max * y_max * z_max, )

np.sum(data)

vals = data = np.fromstring(buf, dtype='uint8')
vals = np.array(data).reshape(x_max, y_max, z_max)
vals.shape

d_sort = np.sort(data)
d_argsort = np.argsort(data)

d_arglist = np.zeros_like(d_argsort)
for x in range(0, d_argsort.shape[0]):
    d_arglist[d_argsort[x]] = x
d_arglist

sorted_vert = np.zeros(shape=(d_sort.shape[0], 3))
vert_map = np.zeros_like(d_argsort)
vertices = np.zeros(shape=(x_max, y_max, z_max))
print(vertices.shape)
# triplets
triplets = np.zeros(shape=(x_max, y_max, z_max))
# print(d_sort.shape)
for x in range(0, d_sort.shape[0]):
    first, second1 = divmod(d_argsort[x], y_max * z_max)
    second, third = divmod(second1, z_max)
    # print (row,col)
    sorted_vert[x] = np.array([first, second, third])
    vertices[first, second, third] = x
print(sorted_vert)


def get_adjacent(i, j, k, xm, ym, zm):
    neigh = list()
    if (i - 1 >= 0 and j - 1 >= 0 and k - 1 >= 0):
        neigh.append((i - 1, j - 1, k - 1))
    if (i - 1 >= 0 and j - 1 >= 0 and k >= 0):
        neigh.append((i - 1, j - 1, k))
    if (i - 1 >= 0 and j >= 0 and k - 1 >= 0):
        neigh.append((i - 1, j, k - 1))
    if (i >= 0 and j - 1 >= 0 and k - 1 >= 0):
        neigh.append((i, j - 1, k - 1))
    if (i + 1 < xm and j + 1 < ym and k + 1 < zm):
        neigh.append((i + 1, j + 1, k + 1))
    if (i + 1 < xm and j + 1 < ym and k >= 0):
        neigh.append((i + 1, j + 1, k))
    if (i + 1 < xm and j >= 0 and k + 1 < zm):
        neigh.append((i + 1, j, k + 1))
    if (i >= 0 and j + 1 < ym and k + 1 < zm):
        neigh.append((i, j + 1, k + 1))
    if (i - 1 >= 0 and j >= 0 and k >= 0):
        neigh.append((i - 1, j, k))
    if (i >= 0 and j - 1 >= 0 and k >= 0):
        neigh.append((i, j - 1, k))
    if (i >= 0 and j >= 0 and k + 1 < zm):
        neigh.append((i, j, k + 1))
    if (i >= 0 and j >= 0 and k + 1 < zm):
        neigh.append((i, j, k + 1))
    if (i >= 0 and j + 1 < ym and k >= 0):
        neigh.append((i, j + 1, k))
    if (i + 1 < xm and j >= 0 and k >= 0):
        neigh.append((i + 1, j, k))
    return neigh


class UnionFind:
    def __init__(self):
        self.nodes = list()

    def add(self, val):
        self.nodes.append((0, len(self.nodes)))

    def find(self, i):
        if self.nodes[i][1] != i:
            self.nodes[i] = (self.nodes[i][0], self.find(self.nodes[i][1]))
        return self.nodes[i][1]

    def merge(self, i, j):
        parent_i, parent_j = self.find(i), self.find(j)
        if parent_i == parent_j:
            return
        if self.nodes[parent_i][0] < self.nodes[parent_j][0]:
            self.nodes[parent_i] = (self.nodes[parent_i][0], parent_j)
        if self.nodes[parent_i][0] > self.nodes[parent_j][0]:
            self.nodes[parent_j] = (self.nodes[parent_j][0], parent_i)
        else:
            self.nodes[parent_i] = (self.nodes[parent_i][0], parent_j)
            self.nodes[parent_j] = (self.nodes[parent_j][0] + 1, self.nodes[parent_j][1])


def get_join_tree(vert, sorted_vert):
    uf = UnionFind()
    lowest_vert = list(range(vert.shape[0] * vert.shape[1] * vert.shape[2]))
    for i in range(len(lowest_vert)):
        uf.add(i)
    join_tree = [[] for x in range(vert.shape[0] * vert.shape[1] * vert.shape[2])]
    for i in range(len(lowest_vert) - 1, -1, -1):
        first, second, third = sorted_vert[i].tolist()
        neighb = get_adjacent(int(first), int(second), int(third), vert.shape[0], vert.shape[1], vert.shape[2])
        for p, j, k in neighb:
            val = vert[int(p), int(j), int(k)]
            if val < i or uf.find(i) == uf.find(val):
                continue
            # smaller = min(i,lowest_vert[uf.find(val)])
            # larger = max(i,lowest_vert[uf.find(val)])
            join_tree[i].append(lowest_vert[uf.find(val)])
            join_tree[lowest_vert[uf.find(val)]].append(i)
            # join_tree[smaller].append(larger)
            uf.merge(i, val)
        lowest_vert[uf.find(i)] = i
    return join_tree


def prune_contour(join_tree):
    for i in range(len(join_tree)):
        node = join_tree[i]
        node_len = len(node)
        if (node_len == 2):
            one = node[0]
            two = node[1]
            try:

                join_tree[one].remove(i)
                join_tree[two].remove(i)
                join_tree[one].append(two)
                join_tree[two].append(one)
                node.remove(one)
                node.remove(two)
            except Exception:
                pass


def prune_2(join_tree, u):
    for i in range(len(join_tree)):
        temp = copy.deepcopy(join_tree[i]);
        for j in temp:
            if (d_sort[j] < d_sort[i] or i == j):
                join_tree[i].remove(j);
    ccount = 0
    for i in range(len(join_tree)):
        temp = copy.deepcopy(join_tree[i]);
        for j in temp:
            if (d_sort[j] - d_sort[i] < u):
                ccount += 1
                join_tree[i] = join_tree[i] + join_tree[j];
                try:
                    # if(i in join_tree[i]):
                    join_tree[i].remove(j);
                except Exception:
                    print(i, j);
                join_tree[j] = [];
    return ccount


def prune_2_new_2(join_tree, sorted_vert, u):
    for i in range(len(join_tree)):
        temp = copy.deepcopy(join_tree[i]);
        for j in temp:
            if (d_sort[j] < d_sort[i] or i == j):
                join_tree[i].remove(j);
    for i in range(len(join_tree)):
        row, col, zdim = sorted_vert[i].tolist();
        if (vals[int(row), int(col), int(zdim)] > u):
            join_tree[i].clear();


u = print(np.percentile(d_sort, 80))
u

join_tree = get_join_tree(vertices.astype(int), sorted_vert.astype(int))
prune_contour(join_tree)
coll_limit = 10
prune_2_new_2(join_tree, sorted_vert, 200)
for i in range(20):
    if prune_2(join_tree, u) < coll_limit:
        print(i)
        break

prune_contour(join_tree)


class Tree:
    def __init__(self, name):
        self.name = int(name)
        self.children = []

    def add_child(self, child_name):
        self.children.append(child_name)


def constructTree(node, index):
    if (visited[index] == 1):
        return
    visited[index] = 1
    l = 0
    children_of_index = join_tree[index]
    i = 0
    for i in range(len(children_of_index)):
        # print (i)
        child = children_of_index[i]
        if (d_sort[child] < d_sort[index]):
            continue;
        tempNode = Tree(d_sort[child])
        l += 1
        # print (d_sort[child])
        node.add_child(tempNode)
        l += constructTree(tempNode, child)
    return l


visited = np.zeros(len(join_tree))
index = 0
JT = Tree(d_sort[index])
# for i in range(len(join_tree)):
l = constructTree(JT, index)
print(l)

# print (JT.children[0].children[0].name)
import jsonpickle

max_rec = 0x1000000

import resource
import sys

# May segfault without this line. 0x100 is a guess at the size of each stack frame.
resource.setrlimit(resource.RLIMIT_STACK, [0x100 * max_rec, resource.RLIM_INFINITY])
sys.setrecursionlimit(max_rec)
print(jsonpickle.encode(JT))

np.max(data)


def get_edge_list(tree):
    edge_list = list()
    for row in range(len(tree)):
        for col in tree[row]:
            if (row, col) not in edge_list and (col, row) not in edge_list:
                edge_list.append((row, col))
    return edge_list


def contract_tree(tree, prune=True):
    G_tree = nx.from_edgelist(get_edge_list(tree))
    return G_tree
    if not prune: return G_tree
    for u in G_tree:
        if u not in G_tree:
            continue
        G = list(G_tree[u])
        while len(G) == 2:
            mx = max(G)
            G_temp = nx.contracted_edge(G_tree, (u, mx))
            G_temp.remove_edges_from(G_temp.selfloop_edges())
            G = list(G_temp[u])
            '''if len(G) >= 3:
        break'''
            G_tree = G_temp
    return G_tree


def draw_tree_pr(tree, prune=True):
    G_tree = contract_tree(tree, prune)
    p = nx.nx_pydot.to_pydot(G_tree)
    plt = Image(p.create_png())
    display(plt)


draw_tree_pr(join_tree)
