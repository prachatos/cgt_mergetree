# -*- coding: utf-8 -*-
"""CGT.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AEr53w5hnutCBGbr_1-Kp8abVMziOy3t
"""

import numpy as np
from collections import deque
import networkx as nx
import matplotlib.pyplot as plt
import graphviz, pydot
from IPython.display import Image, display
import copy

def get_adjacent(i, j, xm, ym):
    neigh = list()
    if i - 1 >= 0 and j - 1 >= 0:
        neigh.append((i - 1, j - 1))
    if i >= 0 and j - 1 >= 0:
        neigh.append((i, j - 1))
    if i - 1 >= 0 and j >= 0:
        neigh.append((i - 1, j))
    if i + 1 < xm and j + 1 < ym:
        neigh.append((i + 1, j + 1))
    if i + 1 < xm and j < ym:
        neigh.append((i + 1, j))
    if i < xm and j + 1 < ym:
        neigh.append((i, j + 1))
    return neigh


class UnionFind:
    def __init__(self):
        self.nodes = list()

    def add(self, val):
        self.nodes.append((0, len(self.nodes)))

    def find(self, i):
        if self.nodes[i][1] != i:
            self.nodes[i] = (self.nodes[i][0], self.find(self.nodes[i][1]))
        return self.nodes[i][1]

    def merge(self, i, j):
        parent_i, parent_j = self.find(i), self.find(j)
        if parent_i == parent_j:
            return
        if self.nodes[parent_i][0] < self.nodes[parent_j][0]:
            self.nodes[parent_i] = (self.nodes[parent_i][0], parent_j)
        if self.nodes[parent_i][0] > self.nodes[parent_j][0]:
            self.nodes[parent_j] = (self.nodes[parent_j][0], parent_i)
        else:
            self.nodes[parent_i] = (self.nodes[parent_i][0], parent_j)
            self.nodes[parent_j] = (self.nodes[parent_j][0] + 1, self.nodes[parent_j][1])


def get_join_tree(vert, sorted_vert):
    uf = UnionFind()
    lowest_vert = list(range(vert.shape[0] * vert.shape[1]))
    for i in range(len(lowest_vert)):
        uf.add(i)
    join_tree = [[] for x in range(vert.shape[0] * vert.shape[1])]
    for i in range(len(lowest_vert) - 1, -1, -1):
        row, col = sorted_vert[i].tolist()
        neighb = get_adjacent(int(row), int(col), vert.shape[0], vert.shape[1])
        for j, k in neighb:
            val = vert[int(j), int(k)]
            if val < i or uf.find(i) == uf.find(val):
                continue
            join_tree[i].append(lowest_vert[uf.find(val)])
            join_tree[lowest_vert[uf.find(val)]].append(i)
            uf.merge(i, val)
        lowest_vert[uf.find(i)] = i
    return join_tree


class Tree:
    def __init__(self, name):
        self.name = int(name)
        self.children = []

    def add_child(self, child_name):
        self.children.append(child_name)


def construct_tree(node, index, visited):
    if visited[index] == 1:
        return 0
    visited[index] = 1
    children_of_index = join_tree[index]
    i = 0
    l = 0
    for i in range(len(children_of_index)):
        # print (i)
        child = children_of_index[i]
        if d_sort[child] < d_sort[index]:
            continue
        tempNode = Tree(d_sort[child])
        l += 1
        # print (d_sort[child])
        node.add_child(tempNode)
        l += construct_tree(tempNode, child, visited)
    return l


def get_json(join_tree, d_sort, visited):
    visited = np.zeros(len(join_tree))
    index = 0
    JT = Tree(d_sort[index])
    construct_tree(JT, index, visited)
    print()

    import jsonpickle

    max_rec = 0x1000000

    import resource
    import sys

    # May segfault without this line. 0x100 is a guess at the size of each stack frame.
    resource.setrlimit(resource.RLIMIT_STACK, [0x100 * max_rec, resource.RLIM_INFINITY])
    sys.setrecursionlimit(max_rec)
    jst = jsonpickle.encode(JT)
    return jst


def prune_contour(join_tree):
    for i in range(len(join_tree)):
        node = join_tree[i]
        node_len = len(node)
        if node_len == 2:
            one = node[0]
            two = node[1]
            join_tree[one].remove(i)
            join_tree[two].remove(i)
            join_tree[one].append(two)
            join_tree[two].append(one)
            node.remove(one)
            node.remove(two)


def prune_approach_1(join_tree, u):
    for i in range(len(join_tree)):
        temp = copy.deepcopy(join_tree[i]);
        for j in temp:
            if d_sort[j] < d_sort[i] or i == j:
                join_tree[i].remove(j)
    ccount = 0
    for i in range(len(join_tree)):
        temp = copy.deepcopy(join_tree[i])
        for j in temp:
            if d_sort[j] - d_sort[i] < u:
                ccount += 1
                join_tree[i] = join_tree[i] + join_tree[j]
                try:
                    # if(i in join_tree[i]):
                    join_tree[i].remove(j)
                except Exception:
                    print(i, j)
                join_tree[j] = []
    return ccount


def prune_approach_2(join_tree, sorted_vert, u):
    i = len(join_tree) - 1
    while i >= 0:
        row, col = sorted_vert[i].tolist()
        # print(row,col)
        if vals[row, col] > u:
            temp = copy.deepcopy(join_tree[i])
            for j in temp:
                if not (join_tree[j]):
                    join_tree[i].remove(j)
                    join_tree[j] = []
        i = i - 1


def prune_approach_2_v2(join_tree, sorted_vert, u):
    for i in range(len(join_tree)):
        temp = copy.deepcopy(join_tree[i]);
        for j in temp:
            if d_sort[j] < d_sort[i] or i == j:
                join_tree[i].remove(j)
    for i in range(len(join_tree)):
        row, col = sorted_vert[i].tolist()
        if vals[row, col] > u:
            join_tree[i].clear()


def get_split_tree(vert, sorted_vert):
    uf = UnionFind()
    highest_vert = list(range(vert.shape[0] * vert.shape[1]))
    for i in range(len(highest_vert)):
        uf.add(i)
    split_tree = [[] for x in range(vert.shape[0] * vert.shape[1])]
    for i in range(len(highest_vert)):
        highest_vert[i] = i
        row, col = sorted_vert[i].tolist()
        neighb = get_adjacent(row, col, vert.shape[0], vert.shape[1])
        for j, k in neighb:
            val = vert[int(j), int(k)]
            if val > i or uf.find(i) == uf.find(val):
                continue
            split_tree[i].append(highest_vert[uf.find(val)])
            split_tree[highest_vert[uf.find(val)]].append(i)
            uf.merge(i, val)
        highest_vert[uf.find(i)] = i
    return split_tree


def up_degree(tree, vertex):
    counter = 0
    for n in tree[vertex]:
        if vertex < n:
            counter += 1
    return counter


def down_degree(tree, vertex):
    return len(tree[vertex]) - up_degree(tree, vertex)


def collapse_tree(tree, vertex):
    for neigh in tree[vertex]:
        tree[neigh] = list(filter(lambda a: a != vertex, tree[neigh]))

    for vi in tree[vertex]:
        for vj in tree[vertex]:
            if vi != vj and vj not in tree[vi]:
                tree[vi].append(vj)
    tree[vertex] = list()
    return tree


def get_contour_tree(join_tree, split_tree):
    q = deque()

    for i in range(len(join_tree)):
        if up_degree(join_tree, i) + down_degree(split_tree, i) == 1:
            q.append(i)

    contour_tree = [[] for x in range(len(join_tree))]

    while len(q):
        head = q.popleft()
        j = -1
        if up_degree(join_tree, head) == 0 and down_degree(split_tree, head) == 1:
            j = join_tree[head][0]
        elif up_degree(join_tree, head) == 1 and down_degree(split_tree, head) == 0:
            j = split_tree[head][0]
        elif up_degree(join_tree, head) == 0 and down_degree(split_tree, head) == 0:
            break
        else:
            raise Exception('Impossible situation!')

        contour_tree[head].append(j)
        contour_tree[j].append(head)

        join_tree = collapse_tree(join_tree, head);
        split_tree = collapse_tree(split_tree, head);

        if up_degree(join_tree, j) + down_degree(split_tree, j) == 1:
            q.append(j)
    return contour_tree


def get_edge_list(tree):
    edge_list = list()
    for row in range(len(tree)):
        for col in tree[row]:
            if (row, col) not in edge_list and (col, row) not in edge_list:
                edge_list.append((row, col))
    return edge_list


def draw_tree(tree):
    G_tree = nx.from_edgelist(get_edge_list(tree))
    p = nx.nx_pydot.to_pydot(G_tree)
    plt = Image(p.create_png())
    display(plt)

def get_percentile(vals):
    edges = []
    rand_x = np.random.choice(vals.shape[0], int(0.5 * vals.shape[0]), replace=False)
    rand_y = np.random.choice(vals.shape[1], int(0.5 * vals.shape[0]), replace=False)
    print(rand_x)
    for i in rand_x:
        print('Doing', i)
        for j in rand_y:
            x = get_adjacent(i, j, vals.shape[0], vals.shape[1])
            for v in x:
                edges.append(abs(vals[i, j] - vals[v[0], v[1]]))
    u = np.percentile(edges, 65)
    w = np.percentile(d_sort, 80)
    return u, w

def contract_tree(tree):
    G_tree = nx.from_edgelist(get_edge_list(tree))
    for u in G_tree:
        if u not in G_tree:
            continue
        G = list(G_tree[u])
        while len(G) == 2:
            mx = max(G)
            G_temp = nx.contracted_edge(G_tree, (u, mx))
            G_temp.remove_edges_from(G_temp.selfloop_edges())
            G = list(G_temp[u])
            '''if len(G) >= 3:
        break'''
            G_tree = G_temp
    return G_tree


def draw_tree_pr(tree):
    G_tree = contract_tree(tree)
    p = nx.nx_pydot.to_pydot(G_tree)
    plt = Image(p.create_png())
    display(plt)


def draw_all():
    draw_tree_pr(join_tree)

    draw_tree(join_tree)

    draw_tree_pr(contour_tree)

    draw_tree(split_tree)

    draw_tree(contour_tree)


if __name__ == '__main__':

    # 5x5 grid for testing
    data = np.array([[100, 78, 49, 17, 1], [94, 71, 47, 33, 6],
                     [52, 44, 50, 45, 48], [8, 12, 46, 91, 43],
                     [0, 5, 51, 76, 83]])

    x_max, y_max = data.shape

    data = data.reshape(x_max, y_max)
    vals = copy.deepcopy(data)
    data = data.reshape(x_max * y_max, )

    """We sort the data and store the matrix containing argument indices corresponding to sorted array."""
    time = cpu.time()
    d_sort = np.sort(data)
    d_argsort = np.argsort(data)
    print(d_sort)
    print(d_argsort)

    d_arglist = np.zeros_like(d_argsort)
    for x in range(0, d_argsort.shape[0]):
        d_arglist[d_argsort[x]] = x

    sorted_vert = np.zeros(shape=(d_sort.shape[0], 2))
    vert_map = np.zeros_like(d_argsort)
    vertices = np.zeros(shape=(x_max, y_max))
    # triplets
    triplets = np.zeros(shape=(x_max, y_max))
    # print(d_sort.shape)
    for x in range(0, d_sort.shape[0]):
        row, col = divmod(d_argsort[x], y_max)
        sorted_vert[x] = np.array([row, col])
        vertices[row, col] = x

    join_tree = get_join_tree(vertices.astype(int), sorted_vert.astype(int))
    print(cpu.time() - time)
    prune_contour(join_tree)
    coll_limit = 10
    u, w = get_percentile(vals)
    for i in range(200):
      if prune_2(join_tree, u) < coll_limit:
        break
    prune_2_new_2(join_tree, sorted_vert.astype(int), w)
    print(get_json(join_tree=join_tree, d_sort=d_sort, visited=visited))