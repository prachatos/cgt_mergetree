# -*- coding: utf-8 -*-
"""TNT

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1styyPR_IH9oTSBLkIn6pW6yVBZGaE3Va
"""

import numpy as np
from collections import deque 
import networkx as nx
import matplotlib.pyplot as plt
import graphviz, pydot
from IPython.display import Image, display
import copy
def get_adjacent(i, j, xm, ym):
  neigh = list()
  if (i - 1 >= 0 and j - 1 >= 0):
    neigh.append([i, j, i - 1, j - 1])
  if (i >= 0 and j - 1 >= 0):
    neigh.append([i, j, i, j - 1])
  if (i - 1 >= 0 and j  >= 0):
    neigh.append([i, j, i - 1, j])
  if (i + 1 < xm and j + 1 < ym):
    neigh.append([i, j, i + 1, j + 1])
  if (i + 1 < xm and j < ym):
    neigh.append([i, j, i + 1, j])
  if (i < xm and j + 1 < ym):
    neigh.append([i, j, i, j + 1])
  return neigh

class Triplet:
  def __init__(self, ux, uy, val):
    self.u = [ux, uy, val]
    self.s = [ux, uy, val]
    self.v = [ux, uy, val]
  
  def set_s(self, sx, sy, val):
    #print("My u", self.u)
    #print("My old s", self.s)
    self.s = [int(sx), int(sy), int(val)]
    #print("My new s", self.s)
  
  def set_v(self, vx, vy, val):
    self.v = [int(vx), int(vy), int(val)]
  
  def p(self):
    u = self.u
    v = self.v
    s = self.s
    print(u[2], s[2], v[2])
  
  
  def p_full(self):
    print(self.u, self.s, self.v)

def repair(T, u):
  ux, uy = u[0], u[1]
  s = T[ux][uy].s
  r = get_representative(T, u, s[2])
  r.p()
  v = r.v
  if not(u[0] == v[0] and u[1] == v[1]):
    T[ux][uy].set_s(s[0], s[1], s[2])
    T[ux][uy].set_v(v[0], v[1], v[2])
  return T[ux][uy]

def get_representative(Triplet_List, u, a):
  T = Triplet_List[u[0]][u[1]]
  s = T.s
  v =  T.v

  while s[2] <= a and not (s[0] == v[0] and s[1] == v[1]):
    u = v
    s = Triplet_List[u[0]][u[1]].s
    v = Triplet_List[u[0]][u[1]].v
  T = Triplet(u[0], u[1], u[2])
  T.set_s(s[0], s[1], s[2])
  T.set_v(v[0], v[1], v[2])
  return T

def merge(Triplet_List, u, s, v):
  T1 = get_representative(Triplet_List, u, s[2])
  T2 = get_representative(Triplet_List, v, s[2])
  if(T1.u[0] == T2.u[0] and T1.u[1] == T2.u[1]):
    return
  if T2.u[2] < T1.u[2]:
    t1, t2, t3 = T2.u, T2.v, T2.s
    T2.u, T2.v, T2.s = T1.u, T1.v, T1.s
    T1.u, T1.v, T1.s =  t1, t2, t3 
  Triplet_List[T2.u[0]][T2.u[1]].set_s(T1.s[0], T1.s[1],T1.s[2])
  Triplet_List[T2.u[0]][T2.u[1]].set_v(T1.u[0], T1.u[1], T1.u[2])
  #Triplet_List[T2.u[0]][T2.u[1]].p_full()
  merge(Triplet_List, T1.u, T2.s, T2.v)


import copy
def compute_mt(mesh, r=True):
  T = []
  edges = []
  for i in range(mesh.shape[0]):
    T.append([])
    for j in range(mesh.shape[1]):
      T[i].append(Triplet(i, j, mesh[i, j]))
      edges = edges + get_adjacent(i, j, mesh.shape[0], mesh.shape[1])
  #done = {}
  el = 0
  for e in edges:
    # Magic(TM) to force unique edges
    ec = e
    ec[1], ec[3] = min(e[1],e[3]), max(e[1], e[3])
    ec[0], ec[2] = min(e[0],e[2]), max(e[0], e[2])
    str_e = " ".join(map(str, list(ec)))
    if str_e in done:
      continue
    done.append(str_e)
    el += 1
    v = [e[2], e[3], mesh[e[2], e[3]]]
    u = [e[0], e[1], mesh[e[0], e[1]]]
    if mesh[e[0]][e[1]] < mesh[e[2]][e[3]]:
      merge(T,  v,  v,  u)
    else:
      merge(T, u,  u,   v)
  if r:
    for i in range(mesh.shape[0]):
      for j in range(mesh.shape[1]):
         x = repair(T, T[i][j].u)
  return T

if __name__ == '__main__':
    data = np.array([[100, 78, 49, 17, 1], [94, 71, 47, 33, 6],
                     [52, 44, 50, 45, 48], [8, 12, 46, 91, 43],
                    [ 0,  5, 51, 76, 83]])
    ans = compute_mt(data, False)

    for i in range(len(ans)):
      for j in range(len(ans[0])):
        ans[i][j].p_full()

    for i in range(len(ans)):
      for j in range(len(ans[0])):
        ans[i][j].p_full()